<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="refresh" content="60"> 
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Binance Futures Data Chart</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%; 
            overflow: hidden; 
        }
        #container {
            width: 100%; 
            height: 100%;
        }
    </style>
    <script src="jslib/jquery-3.7.0.js"></script>
    <script src="jslib/highstock-12.4.0.js"></script>
    <script src="jslib/highcharts-more-12.4.0.js"></script>
    <script src="jslib/accessibility-12.4.0.js"></script>
</head>
<body>
    <div id="container"></div>
    <script>
        //初始化参数
        function getUrlParam(key, defaultValue) {
            const value = new URLSearchParams(window.location.search).get(key);
            return (value || defaultValue);
        }

        const INTERVALS = {
            '5m':  {ts: 300000, period: 0, linearNum: 288, days: 2},
            '15m': {ts: 900000, period: 1, linearNum: 192, days: 3},
            '30m': {ts: 1800000, period: 2, linearNum: 144, days: 4},
            '1h':  {ts: 3600000, period: 3, linearNum: 168, days: 8},
            '4h':  {ts: 14400000, period: 4, linearNum: 168, days: 29}
        };
        const intervalName = getUrlParam('interval', '5m');
        const interval = INTERVALS[intervalName];
        const dataContext = {
            symbol: getUrlParam('symbol', 'BTCUSDT').toUpperCase(),
            prices: [],
            pricesLNR: [],
            pricesPrecision: parseInt(getUrlParam('pricesPrecision', 2)),
            volumes: [],
            opensU: [],
            opensULNR: [],
            opensUPrecision: parseInt(getUrlParam('opensUPrecision', 2)),
            ratios: [],
            longshorts: [],
            interval: intervalName,
            intervalTS: interval.ts,
            initPeriod: interval.period,
            linearNum: interval.linearNum,
            startTime: null,
            endTime: null,
            buildRange: function(n){
                this.endTime = parseInt(new Date().getTime() / this.intervalTS) * this.intervalTS
                this.startTime = this.endTime - 86400000 * n;
            }
        };
        dataContext.buildRange(parseInt(getUrlParam('days', interval.days)));

        //chart渲染
        function createChart(){
            console.log(dataContext);
            document.title = `${dataContext.longshorts[dataContext.longshorts.length - 1][1]} | 
                                ${dataContext.opensU[dataContext.opensU.length - 1][1]} | 
                                ${dataContext.ratios[dataContext.ratios.length - 1][1]}`;

            Highcharts.stockChart('container', {
                time: {useUTC: false},
                legend: {enabled: true},
                title: {text: `${dataContext.symbol} - ${dataContext.interval}`},
                plotOptions: {series: {dataGrouping: {enabled: false}}},
                rangeSelector: {
                    buttons: [
                        {type: 'day', count: 1, text: '1d'},
                        {type: 'day', count: 2, text: '2d'},
                        {type: 'day', count: 3, text: '3d'}, 
                        {type: 'week', count: 1, text: '1w'}, 
                        {type: 'week', count: 4, text: '4w'}
                    ],
                    selected: dataContext.initPeriod
                },
                yAxis: [
                    {                     
                        title: {text: '价格',style: {color: Highcharts.getOptions().colors[1]}},
                        labels: {style: {color: Highcharts.getOptions().colors[1]}},
                        opposite: false,
                        height: '85%'
                    },{
                        title: {text: '多空比',style: {color: Highcharts.getOptions().colors[1]}},
                        labels: {style: {color: Highcharts.getOptions().colors[1]}},
                        opposite: true,
                        height: '85%'
                    },{
                        labels: {enabled: false},
                        gridLineWidth: 0,
                        height: '85%',
                        visible: false
                    },{
                        labels: {enabled: false},
                        gridLineWidth: 0,
                        height: '85%',
                        visible: false
                    },{
                        labels: {enabled: false},
                        gridLineWidth: 0,
                        height: '25%',
                        top: '75%'
                    }
                ],
                series: [
                    {
                        name: 'Prices',
                        type: 'candlestick',
                        yAxis: 0,
                        data: dataContext.prices,
                        color: 'green',
                        lineColor: 'green',
                        upColor: 'red',
                        upLineColor: 'red'
                    },{
                        name: 'PricesLNR',
                        type: 'areasplinerange',
                        yAxis: 0,
                        data: dataContext.pricesLNR,
                        color: Highcharts.getOptions().colors[0],
                        lineWidth: 0,
                        visible: false,
                        fillOpacity: 0.1
                    },{
                        name: 'LongShorts',
                        type: 'spline',
                        yAxis: 1,
                        data: dataContext.longshorts,
                        color: Highcharts.getOptions().colors[2]
                    },{
                        name: 'Opens(U)',
                        type: 'spline',
                        yAxis: 2,
                        data: dataContext.opensU,
                        dashStyle: 'Dash',
                        color: Highcharts.getOptions().colors[8]
                    },{
                        name: 'Opens(U)LNR',
                        type: 'areasplinerange',
                        yAxis: 2,
                        data: dataContext.opensULNR,
                        color: Highcharts.getOptions().colors[0],
                        lineWidth: 0,
                        visible: false,
                        fillOpacity: 0.1
                    },{
                        name: 'Ratios',
                        type: 'spline',
                        yAxis: 3,
                        data: dataContext.ratios,
                        color: Highcharts.getOptions().colors[4],
                        visible: false
                    },{
                        name: 'Volumes',
                        type: 'column',
                        yAxis: 4,
                        data: dataContext.volumes,
                        color: Highcharts.getOptions().colors[0]
                    }
                ]
            });
        }

        //计算
        function getAvgPrice(item){return (item[1] + item[2] + item[3] + item[4]) / 4}
        function toPrecision(value, n) {
            const precision = Math.pow(10, n);
            return Math.round(value * precision) / precision;
        }

        function linear(source, getValFunc, precisionN){
            const length = source.length;
            let sumx = 0, sumy = 0, sumxx = 0, sumxy = 0;
            for (let i = 1; i <= length; i++){
                const y = getValFunc(source[i-1]);
                sumx += i;
                sumy += y;
                sumxx += (i * i);
                sumxy += (i * y);
            }
            const slope = (length * sumxy - sumx * sumy) / (length * sumxx - sumx * sumx);
            const intercept = sumy / length - slope * sumx / length + slope;
            let stdDevAcc = 0
            for (let i = 1; i <= length; i++){
                const y = getValFunc(source[i-1]);
                stdDevAcc += ((i * slope + intercept - y) * (i * slope + intercept - y));
            }
            const stdDev = Math.sqrt(stdDevAcc / (length - 1));
            const finalPrediction = length * slope + intercept;
            const upper = toPrecision(finalPrediction + 2 * stdDev, precisionN);
            const lower = toPrecision(finalPrediction - 2 * stdDev, precisionN);
            return [source[length - 1][0], upper, lower];
        }

        function calLinearLines(source, target, getValFunc, precisionN){
            for(let i = dataContext.linearNum - 1; i < source.length; i++){
                const subArray = source.slice(i + 1 - dataContext.linearNum, i + 1);
                target.push(linear(subArray, getValFunc, precisionN));
            }
        }

        //请求数据
        const DOMAIN = 'https://fapi.binance.com';
        const PAGE_LIMIT = 500;
        
        function buildEndTime(st){
            return Math.min(st + dataContext.intervalTS * (PAGE_LIMIT - 1), dataContext.endTime);
        }
     
        function buildURL(page, intervalName, startTime, endTime) {
            const url = new URL(DOMAIN + page);
            url.searchParams.set('_ts', dataContext.endTime);
            url.searchParams.set('symbol', dataContext.symbol);
            url.searchParams.set(intervalName, dataContext.interval);
            url.searchParams.set('limit', PAGE_LIMIT);
            url.searchParams.set('startTime', startTime);
            url.searchParams.set('endTime', endTime);
            return url.toString();
        }

        function fetchPaginatedData(page, intervalKey, dataMapper) {
            return new Promise((resolve, reject) => {
                const fetch = (startTime) => {
                    const endTime = buildEndTime(startTime);
                    $.getJSON(buildURL(page, intervalKey, startTime, endTime))
                        .done(data => {
                            data.forEach(dataMapper);
                            if (endTime + dataContext.intervalTS <= dataContext.endTime) {
                                fetch(endTime + dataContext.intervalTS);
                            } else {
                                resolve();
                            }
                        });
                };
                fetch(dataContext.startTime);
            });
        }

        function getRatios(){
            const priceMap = new Map(dataContext.prices.map(item => [item[0], getAvgPrice(item)]));
            dataContext.opensU.forEach(item => {
                if(priceMap.has(item[0])){
                    const ratio = item[1] * 1000 / priceMap.get(item[0]);
                    dataContext.ratios.push([item[0], toPrecision(ratio, 3)]);
                }
            });
        }

        function getOpens(){
            return fetchPaginatedData('/futures/data/openInterestHist', 'period', 
                item => {
                    if (item.sumOpenInterestValue != 0) {
                        dataContext.opensU.push([item.timestamp, 
                        parseInt(parseFloat(item.sumOpenInterestValue)/1000000)/100]);
                    }
                });
        }

        function getKlines(){
            return fetchPaginatedData('/fapi/v1/klines', 'interval', 
                item => {
                    dataContext.prices.push([item[0], parseFloat(item[1]), 
                        parseFloat(item[2]), parseFloat(item[3]), parseFloat(item[4])]);
                    dataContext.volumes.push([item[0], parseFloat(item[5])]);
                });
        }

        function getLongShorts(){
            return fetchPaginatedData('/futures/data/globalLongShortAccountRatio', 'period', 
                item => {
                    dataContext.longshorts.push([item.timestamp, 
                    toPrecision(item.longAccount - item.shortAccount, 3)]);
                });
        }

        Promise.all([getLongShorts(), getKlines(), getOpens()])
            .then(() => {
                calLinearLines(dataContext.prices, dataContext.pricesLNR,
                                getAvgPrice, dataContext.pricesPrecision);
                calLinearLines(dataContext.opensU, dataContext.opensULNR,
                                item => item[1], dataContext.opensUPrecision);
                getRatios();
                createChart();
            });
    </script>
</body>
</html>